#! /usr/bin/env perl

use v5.12;
use warnings;

use FindBin;
use local::lib $FindBin::Bin =~ s{/bin$}{/local-lib}r;
use lib $FindBin::Bin =~ s{/bin$}{/lib}r;

my $project_dir = $FindBin::Bin =~ s{/bin$}{}r;

use IO::Select;
use Term::ReadKey;

use POSIX qw/ WNOHANG setsid /;
use autodie qw/ :all /;
use List::AllUtils qw/ any /;

use JCC::Music::Player::Schema;

use JCC::Music::Player::Rules qw/ update_db_from_file_system genres_to_use /;

$|++;

my $dry_run = any { $_ eq '-n' } @ARGV;

my $child_pid;

$SIG{INT} = sub { kill_child(); exit 0; };
$SIG{TERM} = sub { kill_child(); exit 1; };

my $schema = JCC::Music::Player::Schema->connect("dbi:SQLite:dbname=$project_dir/data/priorities.db", '', '');

my $dir = qq{$ENV{HOME}/Music};
update_db_from_file_system($schema, $dir);

ReadMode 3;

my $min_score = 50;

sub available_tracks {
    $schema->resultset('Track')
        ->search({ genre => { -in => [ genres_to_use() ], }, })
        ->search({ score => { '>=' => $min_score / 100, }, })
}

my @queue;

track: while (1) {
    while (!@queue) {
        @queue = available_tracks->nth_row->all();
    }
    my $row = shift @queue;

    printf "%s (%s) (%d) ", $row->filename =~ s{^\Q$dir/}{}r, $row->genre, $row->score_pct;

    $child_pid = play($row->filename);

    while (!waitpid($child_pid, WNOHANG)) {
        if (defined(my $key = ReadKey(1))) {
            if ($key eq 'n') {
                kill_child();
                $row->add_score(0);
                printf qq{(%d)\n}, $row->score_pct;
                next track;
            } elsif ($key eq '+') {
                $min_score += 10;
                printf qq{(min %d) }, $min_score;
                if ($row->score_pct < $min_score) {
                    kill_child();
                    $row->add_score(0);
                    printf qq{(%d)\n}, $row->score_pct;
                    next track;
                }
            } elsif ($key eq '-') {
                $min_score -= 10;
                printf qq{ (min %d) }, $min_score;
            } elsif ($key eq '/') {
                kill_child();
                printf qq{\n};
                ReadMode 0;
                print q{/ };
                chomp(my $nm = <>);
                push @queue, available_tracks
                    ->search({ filename => { -like => "%$nm%", } })
                    ->all()
                ;
                ReadMode 3;
                next track;
            }
        }
    }

    undef $child_pid;

    if ($dry_run) { printf qq{\n}; next; }

    $row->add_score(1);

    printf qq{(%d)\n}, $row->score_pct;
}

exit 0;

sub play {
    my ($fn) = @_;

    my $pid = fork();
    if ($pid) {
        return $pid;
    } else {
        open STDIN, '<', '/dev/null';
        open STDOUT, '>', '/dev/null';
        open STDIN, '>&', \*STDOUT;
        exit 0 if $dry_run;
        if ($fn =~ m{\.ogg$}) {
            exec 'ogg123', '-q', $fn;
        } elsif ($fn =~ m{\.mp3$}) {
            exec 'mpg123', '-q', $fn;
        }
        exit 1;
    }
}

sub kill_child {
    if ($child_pid) {
        kill 'INT', $child_pid;
        waitpid($child_pid, 0);
        undef $child_pid;
    }
}

END { ReadMode 0; print qq{\n}; }
