#! /usr/bin/env perl

use v5.12;
use warnings;

use FindBin;
use local::lib $FindBin::Bin =~ s{/bin$}{/local-lib}r;
use lib $FindBin::Bin =~ s{/bin$}{/lib}r;

my $project_dir = $FindBin::Bin =~ s{/bin$}{}r;

use IO::Select;
use Term::ReadKey;

use POSIX qw/ WNOHANG setsid /;
use autodie qw/ :all /;
use List::AllUtils qw/ any /;

use JCC::Music::Player::Schema;

use JCC::Music::Player::Rules qw/ update_db_from_file_system genres_to_use /;

$|++;

my $dry_run = any { $_ eq '-n' } @ARGV;

my $child_pid;

$SIG{INT} = sub { kill_child(); exit 0; };
$SIG{TERM} = sub { kill_child(); exit 1; };

my $schema = JCC::Music::Player::Schema->connect("dbi:SQLite:dbname=$project_dir/data/priorities.db", '', '');

my $dir = qq{$ENV{HOME}/Music};
update_db_from_file_system($schema, $dir);

ReadMode 3;

my $tolerance = 0;

sub available_tracks {
    $schema->resultset('Track')
        ->search({ genre => { -in => [ genres_to_use() ], }, })
}

my @queue;

my $hist_length = 10;
my $good_threshold = 90;

my @hist;

sub good_songs() { scalar(grep { $_->score_pct >= $good_threshold } @hist) }

track: while (1) {
    # make room in @hist for new track
    shift @hist while @hist > $hist_length - 1;

    # get new track
    while (!@queue) {
        my $rs = available_tracks;
        # only select good songs until we have 'enough' in history
        $rs = $rs->search({ score => { '>=' => $good_threshold / 100, }, }) if good_songs < $hist_length - $tolerance;
        @queue = $rs->nth_row->all();
    }
    my $row = shift @queue;
    push @hist, $row;

    printf "%s (%s) (%d) ", $row->filename =~ s{^\Q$dir/}{}r, $row->genre, $row->score_pct;

    $child_pid = play($row->filename);

    key: while (!waitpid($child_pid, WNOHANG)) {
        if (defined(my $key = ReadKey(1))) {
            if ($key eq 'y') {
		$row->add_score(1);
		printf qq{(%d) }, $row->score_pct;
            } elsif ($key eq 'n') {
                kill_child();
                $row->add_score(0);
                printf qq{(%d)\n}, $row->score_pct;
                next track;
            } elsif ($key eq '+') {
                next key if $tolerance >= $hist_length;
                $tolerance++;
                printf qq{(tol %d) }, $tolerance;
            } elsif ($key eq '-') {
                next key if $tolerance <= 0;
                $tolerance--;
                printf qq{ (tol %d) }, $tolerance;
                kill_child();
                $row->add_score(0);
                printf qq{(%d)\n}, $row->score_pct;
                next track;
            } elsif ($key eq '/') {
                kill_child();
                printf qq{\n};
                ReadMode 0;
                print q{/ };
                chomp(my $nm = <>);
                push @queue, available_tracks
                    ->search({ filename => { -like => "%$nm%", } })
                    ->all()
                ;
                ReadMode 3;
                next track;
            }
        }
    }

    undef $child_pid;

    if ($dry_run) { printf qq{\n}; next; }

    $row->add_score(1);

    printf qq{(%d)\n}, $row->score_pct;
}

exit 0;

sub play {
    my ($fn) = @_;

    my $pid = fork();
    if ($pid) {
        return $pid;
    } else {
        open STDIN, '<', '/dev/null';
        open STDOUT, '>', '/dev/null';
        open STDIN, '>&', \*STDOUT;
        exit 0 if $dry_run;
        if ($fn =~ m{\.ogg$}) {
            exec 'ogg123', '-q', $fn;
        } elsif ($fn =~ m{\.mp3$}) {
            exec 'mpg123', '-q', $fn;
        }
        exit 1;
    }
}

sub kill_child {
    if ($child_pid) {
        kill 'INT', $child_pid;
        waitpid($child_pid, 0);
        undef $child_pid;
    }
}

END { ReadMode 0; print qq{\n}; }
